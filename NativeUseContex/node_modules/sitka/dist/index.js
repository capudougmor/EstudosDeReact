'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var LogFormat;
(function (LogFormat) {
    LogFormat["JSON"] = "{ \"timestamp\": \"${TIMESTAMP}\", \"level\": \"${LEVEL}\", \"name\": \"${NAME}\", \"message\": \"${MESSAGE}\" }";
    LogFormat["JSON_NO_TIME"] = "{ \"level\": \"${LEVEL}\", \"name\": \"${NAME}\", \"message\": \"${MESSAGE}\" }";
    LogFormat["TEXT"] = "[${TIMESTAMP}] [${LEVEL}] [${NAME}] ${MESSAGE}";
    LogFormat["TEXT_NO_TIME"] = "[${LEVEL}] [${NAME}] ${MESSAGE}";
})(LogFormat = exports.LogFormat || (exports.LogFormat = {}));
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["OFF"] = 1] = "OFF";
    LogLevel[LogLevel["FATAL"] = 2] = "FATAL";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    LogLevel[LogLevel["WARN"] = 4] = "WARN";
    LogLevel[LogLevel["INFO"] = 5] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 6] = "DEBUG";
    LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
    LogLevel[LogLevel["ALL"] = 8] = "ALL";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var Logger = /** @class */ (function () {
    /* Constructor */
    function Logger(config) {
        /* Private Instance Fields */
        this._regexDoubleQuote = /"/g;
        this._regexNewLine = /\n/g;
        this._regexReturn = /\r/g;
        this._regexCtx = /[$%]{CTX:([^}]+)}/;
        this._regexEnv = /[$%]{ENV:([^}]+)}/;
        this._regexEscapedVar = /\\([$%]){/g;
        this._regexEscapedSitkaVar = /([$%])_SITKA_ESCAPED_VAR_{/g;
        this._regexLevel = /[$%]\{LEVEL\}/g;
        this._regexMessage = /[$%]\{MESSAGE\}/g;
        this._regexMessageQuoted = /"[$%]\{MESSAGE\}"/;
        this._regexTimestamp = /[$%]\{TIMESTAMP\}/g;
        this._name = config.name;
        this._context = config.context || {};
        var envLogLevel = this.getEnvVariable('LOG_LEVEL', true).replace(/Log(ger\.)?Level\./, '');
        this._level = config.level
            || (LogLevel.hasOwnProperty(envLogLevel) && LogLevel[envLogLevel])
            || LogLevel.ALL;
        this._logWriter = config.logWriter || undefined;
        this._errorWriter = config.errorWriter || undefined;
        this._format = config.format
            || this.getEnvVariable('LOG_FORMAT', true)
            || (this.getEnvVariable('LAMBDA_TASK_ROOT') || this.getEnvVariable('GCP_PROJECT')
                ? LogFormat.TEXT_NO_TIME : LogFormat.TEXT);
        // Perform static replacements now so fewer are needed for each log entry. -- cwells
        this._format = this._format.replace(this._regexEscapedVar, '$1_SITKA_ESCAPED_VAR_{')
            .replace(/[$%]\{NAME\}/g, this._name);
    }
    /* Public Static Methods */
    Logger.getLogger = function (config) {
        if (config === void 0) { config = 'Sitka'; }
        if (typeof config === 'string') {
            config = { name: config };
        }
        config.name = config.name || 'Sitka';
        if (!this._loggers.hasOwnProperty(config.name)) {
            this._loggers[config.name] = new Logger(config);
        }
        return this._loggers[config.name];
    };
    Logger.setErrorWriter = function (errorWriter) {
        this._errorWriter = errorWriter;
    };
    Logger.setGlobalContext = function (context, value) {
        if (typeof context === 'string') {
            this._globalContext[context] = value;
        }
        else {
            this._globalContext = context;
        }
    };
    Logger.setLogWriter = function (logWriter) {
        this._logWriter = logWriter;
    };
    /* Public Instance Methods */
    Logger.prototype.debug = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (this._level >= LogLevel.DEBUG ? this.log.apply(this, ['DEBUG', message].concat(args)) : false);
    };
    Logger.prototype.error = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (this._level >= LogLevel.ERROR ? this.log.apply(this, ['ERROR', message].concat(args)) : false);
    };
    Logger.prototype.fatal = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (this._level >= LogLevel.FATAL ? this.log.apply(this, ['FATAL', message].concat(args)) : false);
    };
    Logger.prototype.info = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (this._level >= LogLevel.INFO ? this.log.apply(this, ['INFO', message].concat(args)) : false);
    };
    Logger.prototype.setContext = function (context, value) {
        if (typeof context === 'string') {
            this._context[context] = value;
        }
        else {
            this._context = context;
        }
    };
    Logger.prototype.trace = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (this._level >= LogLevel.TRACE ? this.log.apply(this, ['TRACE', message].concat(args)) : false);
    };
    Logger.prototype.warn = function (message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (this._level >= LogLevel.WARN ? this.log.apply(this, ['WARN', message].concat(args)) : false);
    };
    /* Private Instance Methods */
    Logger.prototype.convertToString = function (item) {
        if (typeof item === 'undefined') {
            return 'undefined';
        }
        else if (item === null) {
            return 'null';
        }
        else if (typeof item === 'string') {
            return item;
        }
        else if (Array.isArray(item)) {
            var elements = [];
            for (var _i = 0, item_1 = item; _i < item_1.length; _i++) {
                var element = item_1[_i];
                elements.push(this.convertToString(element));
            }
            return '[ ' + elements.join(', ') + ' ]';
        }
        else if (typeof item === 'object') {
            var properties = [];
            for (var property in item) {
                if (typeof item[property] === 'undefined') {
                    properties.push(property + ': undefined');
                }
                else if (item[property] === null) {
                    properties.push(property + ': null');
                }
                else if (typeof item[property] === 'string') {
                    properties.push(property + ': "' + item[property] + '"');
                }
                else {
                    properties.push(property + ': ' + this.convertToString(item[property]));
                }
            }
            return '{ ' + properties.join(', ') + ' }';
        }
        else if (typeof item === 'function') {
            return item.toString();
        }
        else {
            return JSON.stringify(item);
        }
    };
    Logger.prototype.getEnvVariable = function (property, checkCustom) {
        if (checkCustom === void 0) { checkCustom = false; }
        // The keys check allows unit tests to succeed with env overwritten. -- cwells
        if (process && process.env && Object.keys(process.env).length !== 0) {
            if (checkCustom && process.env.hasOwnProperty(property + '_' + this._name)) {
                return process.env[property + '_' + this._name];
            }
            else if (process.env.hasOwnProperty(property)) {
                return process.env[property];
            }
        }
        return '';
    };
    Logger.prototype.log = function (level, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        message = this.convertToString(message);
        if (this._regexMessageQuoted.test(this._format)) { // Message is inside quotes, so escape it. -- cwells
            message = message.replace(this._regexDoubleQuote, '\\"')
                .replace(this._regexNewLine, '\\n')
                .replace(this._regexReturn, '\\r');
        }
        message = this._format.replace(this._regexLevel, level)
            .replace(this._regexTimestamp, Date())
            .replace(this._regexMessage, message.replace(this._regexEscapedVar, '$1_SITKA_ESCAPED_VAR_{'));
        // Replace ${ENV:VAR} and %{ENV:VAR} with the value of the VAR environment variable. -- cwells
        var matches = message.match(this._regexEnv);
        while (matches && matches.length === 2) {
            message = message.replace(matches[0], this.getEnvVariable(matches[1]));
            matches = message.match(this._regexEnv);
        }
        // Replace ${CTX:VAR} and %{CTX:VAR} with the value of the VAR context variable. -- cwells
        var context = __assign({}, Logger._globalContext, this._context);
        matches = message.match(this._regexCtx);
        while (matches && matches.length === 2) {
            var replacement = void 0;
            if (context.hasOwnProperty(matches[1])) {
                replacement = this.convertToString(context[matches[1]]);
            }
            else { // Attempt to convert dotted vars into object property references. -- cwells
                var propNames = matches[1].split('.');
                if (propNames.length !== 1) {
                    var ctxVar = context;
                    var i = void 0;
                    for (i = 0; i < propNames.length; i++) {
                        if (!ctxVar.hasOwnProperty(propNames[i])) {
                            i--; // Decrement i to the last successful match. -- cwells
                            break;
                        }
                        ctxVar = ctxVar[propNames[i]];
                    }
                    if (i === propNames.length) { // Reached end of split, so use the value. -- cwells
                        replacement = this.convertToString(ctxVar);
                    }
                }
            }
            message = message.replace(matches[0], replacement || '');
            matches = message.match(this._regexCtx); // Repeat until no matches found. -- cwells
        }
        message = message.replace(this._regexEscapedSitkaVar, '$1{');
        if (level === 'FATAL' || level === 'ERROR') {
            return (this._errorWriter || Logger._errorWriter).apply(void 0, [message].concat(args));
        }
        else {
            return (this._logWriter || Logger._logWriter).apply(void 0, [message].concat(args));
        }
    };
    /* Public Static Fields */
    Logger.Format = LogFormat;
    Logger.Level = LogLevel;
    /* Private Static Fields */
    Logger._globalContext = {};
    Logger._loggers = {};
    Logger._logWriter = console.log; // tslint:disable-line:no-console
    Logger._errorWriter = console.error; // tslint:disable-line:no-console
    return Logger;
}());
exports.Logger = Logger;
//# sourceMappingURL=index.js.map