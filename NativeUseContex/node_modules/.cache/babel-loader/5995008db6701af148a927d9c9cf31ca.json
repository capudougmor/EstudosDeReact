{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { View, Platform, StyleSheet } from 'react-native';\nimport { SafeAreaConsumer } from 'react-native-safe-area-context';\nimport { NavigationHelpersContext, StackActions } from '@react-navigation/native';\nimport { GestureHandlerRootView } from '../GestureHandler';\nimport CardStack from './CardStack';\nimport KeyboardManager from '../KeyboardManager';\nimport HeaderContainer from '../Header/HeaderContainer';\nimport SafeAreaProviderCompat from '../SafeAreaProviderCompat';\nconst GestureHandlerWrapper = GestureHandlerRootView !== null && GestureHandlerRootView !== void 0 ? GestureHandlerRootView : View;\n/**\n * Compare two arrays with primitive values as the content.\n * We need to make sure that both values and order match.\n */\n\nconst isArrayEqual = (a, b) => a.length === b.length && a.every((it, index) => it === b[index]);\n\nexport default class StackView extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      routes: [],\n      previousRoutes: [],\n      previousDescriptors: {},\n      openingRouteKeys: [],\n      closingRouteKeys: [],\n      replacingRouteKeys: [],\n      descriptors: {}\n    });\n\n    _defineProperty(this, \"getGesturesEnabled\", ({\n      route\n    }) => {\n      const descriptor = this.state.descriptors[route.key];\n\n      if (descriptor) {\n        const _descriptor$options = descriptor.options,\n              gestureEnabled = _descriptor$options.gestureEnabled,\n              animationEnabled = _descriptor$options.animationEnabled;\n\n        if (animationEnabled === false) {\n          // When animation is disabled, also disable gestures\n          // The gesture to dismiss a route will look weird when not animated\n          return false;\n        }\n\n        return gestureEnabled !== false;\n      }\n\n      return false;\n    });\n\n    _defineProperty(this, \"getPreviousRoute\", ({\n      route\n    }) => {\n      const _this$state = this.state,\n            closingRouteKeys = _this$state.closingRouteKeys,\n            replacingRouteKeys = _this$state.replacingRouteKeys;\n      const routes = this.state.routes.filter(r => r.key === route.key || !closingRouteKeys.includes(r.key) && !replacingRouteKeys.includes(r.key));\n      const index = routes.findIndex(r => r.key === route.key);\n      return routes[index - 1];\n    });\n\n    _defineProperty(this, \"renderScene\", ({\n      route\n    }) => {\n      const descriptor = this.state.descriptors[route.key] || this.props.descriptors[route.key];\n\n      if (!descriptor) {\n        return null;\n      }\n\n      return descriptor.render();\n    });\n\n    _defineProperty(this, \"renderHeader\", props => {\n      return /*#__PURE__*/React.createElement(HeaderContainer, props);\n    });\n\n    _defineProperty(this, \"handleOpenRoute\", ({\n      route\n    }) => {\n      const _this$props2 = this.props,\n            state = _this$props2.state,\n            navigation = _this$props2.navigation;\n      const _this$state2 = this.state,\n            closingRouteKeys = _this$state2.closingRouteKeys,\n            replacingRouteKeys = _this$state2.replacingRouteKeys;\n\n      if (closingRouteKeys.some(key => key === route.key) && replacingRouteKeys.every(key => key !== route.key) && state.routeNames.includes(route.name) && !state.routes.some(r => r.key === route.key)) {\n        // If route isn't present in current state, but was closing, assume that a close animation was cancelled\n        // So we need to add this route back to the state\n        navigation.navigate(route);\n      } else {\n        this.setState(state => ({\n          routes: state.replacingRouteKeys.length ? state.routes.filter(r => !state.replacingRouteKeys.includes(r.key)) : state.routes,\n          openingRouteKeys: state.openingRouteKeys.filter(key => key !== route.key),\n          closingRouteKeys: state.closingRouteKeys.filter(key => key !== route.key),\n          replacingRouteKeys: []\n        }));\n      }\n    });\n\n    _defineProperty(this, \"handleCloseRoute\", ({\n      route\n    }) => {\n      const _this$props3 = this.props,\n            state = _this$props3.state,\n            navigation = _this$props3.navigation;\n\n      if (state.routes.some(r => r.key === route.key)) {\n        // If a route exists in state, trigger a pop\n        // This will happen in when the route was closed from the card component\n        // e.g. When the close animation triggered from a gesture ends\n        navigation.dispatch(_objectSpread(_objectSpread({}, StackActions.pop()), {}, {\n          source: route.key,\n          target: state.key\n        }));\n      } else {\n        // We need to clean up any state tracking the route and pop it immediately\n        this.setState(state => ({\n          routes: state.routes.filter(r => r.key !== route.key),\n          openingRouteKeys: state.openingRouteKeys.filter(key => key !== route.key),\n          closingRouteKeys: state.closingRouteKeys.filter(key => key !== route.key)\n        }));\n      }\n    });\n\n    _defineProperty(this, \"handleTransitionStart\", ({\n      route\n    }, closing) => this.props.navigation.emit({\n      type: 'transitionStart',\n      data: {\n        closing\n      },\n      target: route.key\n    }));\n\n    _defineProperty(this, \"handleTransitionEnd\", ({\n      route\n    }, closing) => this.props.navigation.emit({\n      type: 'transitionEnd',\n      data: {\n        closing\n      },\n      target: route.key\n    }));\n\n    _defineProperty(this, \"handleGestureStart\", ({\n      route\n    }) => {\n      this.props.navigation.emit({\n        type: 'gestureStart',\n        target: route.key\n      });\n    });\n\n    _defineProperty(this, \"handleGestureEnd\", ({\n      route\n    }) => {\n      this.props.navigation.emit({\n        type: 'gestureEnd',\n        target: route.key\n      });\n    });\n\n    _defineProperty(this, \"handleGestureCancel\", ({\n      route\n    }) => {\n      this.props.navigation.emit({\n        type: 'gestureCancel',\n        target: route.key\n      });\n    });\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // If there was no change in routes, we don't need to compute anything\n    if ((props.state.routes === state.previousRoutes || isArrayEqual(props.state.routes.map(r => r.key), state.previousRoutes.map(r => r.key))) && state.routes.length) {\n      let routes = state.routes;\n      let previousRoutes = state.previousRoutes;\n      let descriptors = props.descriptors;\n      let previousDescriptors = state.previousDescriptors;\n\n      if (props.descriptors !== state.previousDescriptors) {\n        descriptors = state.routes.reduce((acc, route) => {\n          acc[route.key] = props.descriptors[route.key] || state.descriptors[route.key];\n          return acc;\n        }, {});\n        previousDescriptors = props.descriptors;\n      }\n\n      if (props.state.routes !== state.previousRoutes) {\n        // if any route objects have changed, we should update them\n        const map = props.state.routes.reduce((acc, route) => {\n          acc[route.key] = route;\n          return acc;\n        }, {});\n        routes = state.routes.map(route => map[route.key] || route);\n        previousRoutes = props.state.routes;\n      }\n\n      return {\n        routes,\n        previousRoutes,\n        descriptors,\n        previousDescriptors\n      };\n    } // Here we determine which routes were added or removed to animate them\n    // We keep a copy of the route being removed in local state to be able to animate it\n\n\n    let routes = props.state.index < props.state.routes.length - 1 ? // Remove any extra routes from the state\n    // The last visible route should be the focused route, i.e. at current index\n    props.state.routes.slice(0, props.state.index + 1) : props.state.routes; // Now we need to determine which routes were added and removed\n\n    let openingRouteKeys = state.openingRouteKeys,\n        closingRouteKeys = state.closingRouteKeys,\n        replacingRouteKeys = state.replacingRouteKeys,\n        previousRoutes = state.previousRoutes;\n    const previousFocusedRoute = previousRoutes[previousRoutes.length - 1];\n    const nextFocusedRoute = routes[routes.length - 1];\n\n    const isAnimationEnabled = key => {\n      const descriptor = props.descriptors[key] || state.descriptors[key];\n      return descriptor ? descriptor.options.animationEnabled !== false : true;\n    };\n\n    const getAnimationTypeForReplace = key => {\n      var _descriptor$options$a;\n\n      const descriptor = props.descriptors[key] || state.descriptors[key];\n      return (_descriptor$options$a = descriptor.options.animationTypeForReplace) !== null && _descriptor$options$a !== void 0 ? _descriptor$options$a : 'push';\n    };\n\n    if (previousFocusedRoute && previousFocusedRoute.key !== nextFocusedRoute.key) {\n      // We only need to animate routes if the focused route changed\n      // Animating previous routes won't be visible coz the focused route is on top of everything\n      if (!previousRoutes.some(r => r.key === nextFocusedRoute.key)) {\n        // A new route has come to the focus, we treat this as a push\n        // A replace can also trigger this, the animation should look like push\n        if (isAnimationEnabled(nextFocusedRoute.key) && !openingRouteKeys.includes(nextFocusedRoute.key)) {\n          // In this case, we need to animate pushing the focused route\n          // We don't care about animating any other added routes because they won't be visible\n          openingRouteKeys = [...openingRouteKeys, nextFocusedRoute.key];\n          closingRouteKeys = closingRouteKeys.filter(key => key !== nextFocusedRoute.key);\n          replacingRouteKeys = replacingRouteKeys.filter(key => key !== nextFocusedRoute.key);\n\n          if (!routes.some(r => r.key === previousFocusedRoute.key)) {\n            // The previous focused route isn't present in state, we treat this as a replace\n            openingRouteKeys = openingRouteKeys.filter(key => key !== previousFocusedRoute.key);\n\n            if (getAnimationTypeForReplace(nextFocusedRoute.key) === 'pop') {\n              closingRouteKeys = [...closingRouteKeys, previousFocusedRoute.key]; // By default, new routes have a push animation, so we add it to `openingRouteKeys` before\n              // But since user configured it to animate the old screen like a pop, we need to add this without animation\n              // So remove it from `openingRouteKeys` which will remove the animation\n\n              openingRouteKeys = openingRouteKeys.filter(key => key !== nextFocusedRoute.key); // Keep the route being removed at the end to animate it out\n\n              routes = [...routes, previousFocusedRoute];\n            } else {\n              replacingRouteKeys = [...replacingRouteKeys, previousFocusedRoute.key];\n              closingRouteKeys = closingRouteKeys.filter(key => key !== previousFocusedRoute.key); // Keep the old route in the state because it's visible under the new route, and removing it will feel abrupt\n              // We need to insert it just before the focused one (the route being pushed)\n              // After the push animation is completed, routes being replaced will be removed completely\n\n              routes = routes.slice();\n              routes.splice(routes.length - 1, 0, previousFocusedRoute);\n            }\n          }\n        }\n      } else if (!routes.some(r => r.key === previousFocusedRoute.key)) {\n        // The previously focused route was removed, we treat this as a pop\n        if (isAnimationEnabled(previousFocusedRoute.key) && !closingRouteKeys.includes(previousFocusedRoute.key)) {\n          closingRouteKeys = [...closingRouteKeys, previousFocusedRoute.key]; // Sometimes a route can be closed before the opening animation finishes\n          // So we also need to remove it from the opening list\n\n          openingRouteKeys = openingRouteKeys.filter(key => key !== previousFocusedRoute.key);\n          replacingRouteKeys = replacingRouteKeys.filter(key => key !== previousFocusedRoute.key); // Keep a copy of route being removed in the state to be able to animate it\n\n          routes = [...routes, previousFocusedRoute];\n        }\n      } else {// Looks like some routes were re-arranged and no focused routes were added/removed\n        // i.e. the currently focused route already existed and the previously focused route still exists\n        // We don't know how to animate this\n      }\n    } else if (replacingRouteKeys.length || closingRouteKeys.length) {\n      // Keep the routes we are closing or replacing if animation is enabled for them\n      routes = routes.slice();\n      routes.splice(routes.length - 1, 0, ...state.routes.filter(({\n        key\n      }) => isAnimationEnabled(key) ? replacingRouteKeys.includes(key) || closingRouteKeys.includes(key) : false));\n    }\n\n    if (!routes.length) {\n      throw new Error('There should always be at least one route in the navigation state.');\n    }\n\n    const descriptors = routes.reduce((acc, route) => {\n      acc[route.key] = props.descriptors[route.key] || state.descriptors[route.key];\n      return acc;\n    }, {});\n    return {\n      routes,\n      previousRoutes: props.state.routes,\n      previousDescriptors: props.descriptors,\n      openingRouteKeys,\n      closingRouteKeys,\n      replacingRouteKeys,\n      descriptors\n    };\n  }\n\n  render() {\n    const _this$props = this.props,\n          state = _this$props.state,\n          navigation = _this$props.navigation,\n          keyboardHandlingEnabled = _this$props.keyboardHandlingEnabled,\n          _this$props$mode = _this$props.mode,\n          mode = _this$props$mode === void 0 ? 'card' : _this$props$mode,\n          _this$props$headerMod = _this$props.headerMode,\n          headerMode = _this$props$headerMod === void 0 ? mode === 'card' && Platform.OS === 'ios' ? 'float' : 'screen' : _this$props$headerMod,\n          _ = _this$props.descriptors,\n          rest = _objectWithoutProperties(_this$props, [\"state\", \"navigation\", \"keyboardHandlingEnabled\", \"mode\", \"headerMode\", \"descriptors\"]);\n\n    const _this$state3 = this.state,\n          routes = _this$state3.routes,\n          descriptors = _this$state3.descriptors,\n          openingRouteKeys = _this$state3.openingRouteKeys,\n          closingRouteKeys = _this$state3.closingRouteKeys;\n    return /*#__PURE__*/React.createElement(NavigationHelpersContext.Provider, {\n      value: navigation\n    }, /*#__PURE__*/React.createElement(GestureHandlerWrapper, {\n      style: styles.container\n    }, /*#__PURE__*/React.createElement(SafeAreaProviderCompat, null, /*#__PURE__*/React.createElement(SafeAreaConsumer, null, insets => /*#__PURE__*/React.createElement(KeyboardManager, {\n      enabled: keyboardHandlingEnabled !== false\n    }, props => /*#__PURE__*/React.createElement(CardStack, _extends({\n      mode: mode,\n      insets: insets,\n      getPreviousRoute: this.getPreviousRoute,\n      getGesturesEnabled: this.getGesturesEnabled,\n      routes: routes,\n      openingRouteKeys: openingRouteKeys,\n      closingRouteKeys: closingRouteKeys,\n      onOpenRoute: this.handleOpenRoute,\n      onCloseRoute: this.handleCloseRoute,\n      onTransitionStart: this.handleTransitionStart,\n      onTransitionEnd: this.handleTransitionEnd,\n      renderHeader: this.renderHeader,\n      renderScene: this.renderScene,\n      headerMode: headerMode,\n      state: state,\n      descriptors: descriptors,\n      onGestureStart: this.handleGestureStart,\n      onGestureEnd: this.handleGestureEnd,\n      onGestureCancel: this.handleGestureCancel\n    }, rest, props)))))));\n  }\n\n}\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});","map":null,"metadata":{},"sourceType":"module"}