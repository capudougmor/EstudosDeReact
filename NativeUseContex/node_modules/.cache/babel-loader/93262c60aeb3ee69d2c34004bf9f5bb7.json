{"ast":null,"code":"import { Animated } from 'react-native';\nimport { isIphoneX } from 'react-native-iphone-x-helper';\nimport conditional from '../utils/conditional';\nconst add = Animated.add,\n      multiply = Animated.multiply;\n/**\n * Standard iOS-style slide in from the right.\n */\n\nexport function forHorizontalIOS({\n  current,\n  next,\n  inverted,\n  layouts: {\n    screen\n  }\n}) {\n  const translateFocused = multiply(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [screen.width, 0],\n    extrapolate: 'clamp'\n  }), inverted);\n  const translateUnfocused = next ? multiply(next.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, screen.width * -0.3],\n    extrapolate: 'clamp'\n  }), inverted) : 0;\n  const overlayOpacity = current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 0.07],\n    extrapolate: 'clamp'\n  });\n  const shadowOpacity = current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 0.3],\n    extrapolate: 'clamp'\n  });\n  return {\n    cardStyle: {\n      transform: [// Translation for the animation of the current card\n      {\n        translateX: translateFocused\n      }, // Translation for the animation of the card on top of this\n      {\n        translateX: translateUnfocused\n      }]\n    },\n    overlayStyle: {\n      opacity: overlayOpacity\n    },\n    shadowStyle: {\n      shadowOpacity\n    }\n  };\n}\n/**\n * Standard iOS-style slide in from the bottom (used for modals).\n */\n\nexport function forVerticalIOS({\n  current,\n  inverted,\n  layouts: {\n    screen\n  }\n}) {\n  const translateY = multiply(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [screen.height, 0],\n    extrapolate: 'clamp'\n  }), inverted);\n  return {\n    cardStyle: {\n      transform: [// Translation for the animation of the current card\n      {\n        translateY\n      }]\n    }\n  };\n}\n/**\n * Standard iOS-style modal animation in iOS 13.\n */\n\nexport function forModalPresentationIOS({\n  index,\n  current,\n  next,\n  inverted,\n  layouts: {\n    screen\n  },\n  insets\n}) {\n  const isLandscape = screen.width > screen.height;\n  const topOffset = isLandscape ? 0 : 10;\n  const statusBarHeight = insets.top;\n  const aspectRatio = screen.height / screen.width;\n  const progress = add(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 1],\n    extrapolate: 'clamp'\n  }), next ? next.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 1],\n    extrapolate: 'clamp'\n  }) : 0);\n  const translateY = multiply(progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: [screen.height, index === 0 ? 0 : topOffset, (index === 0 ? statusBarHeight : 0) - topOffset * aspectRatio]\n  }), inverted);\n  const overlayOpacity = progress.interpolate({\n    inputRange: [0, 1, 1.0001, 2],\n    outputRange: [0, 0.3, 1, 1]\n  });\n  const scale = isLandscape ? 1 : progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: [1, 1, screen.width ? 1 - topOffset * 2 / screen.width : 1]\n  });\n  const borderRadius = isLandscape ? 0 : index === 0 ? progress.interpolate({\n    inputRange: [0, 1, 1.0001, 2],\n    outputRange: [0, 0, isIphoneX() ? 38 : 0, 10]\n  }) : 10;\n  return {\n    cardStyle: {\n      overflow: 'hidden',\n      borderTopLeftRadius: borderRadius,\n      borderTopRightRadius: borderRadius,\n      marginTop: index === 0 ? 0 : statusBarHeight,\n      marginBottom: index === 0 ? 0 : topOffset,\n      transform: [{\n        translateY\n      }, {\n        scale\n      }]\n    },\n    overlayStyle: {\n      opacity: overlayOpacity\n    }\n  };\n}\n/**\n * Standard Android-style fade in from the bottom for Android Oreo.\n */\n\nexport function forFadeFromBottomAndroid({\n  current,\n  inverted,\n  layouts: {\n    screen\n  },\n  closing\n}) {\n  const translateY = multiply(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [screen.height * 0.08, 0],\n    extrapolate: 'clamp'\n  }), inverted);\n  const opacity = conditional(closing, current.progress, current.progress.interpolate({\n    inputRange: [0, 0.5, 0.9, 1],\n    outputRange: [0, 0.25, 0.7, 1]\n  }));\n  return {\n    cardStyle: {\n      opacity,\n      transform: [{\n        translateY\n      }]\n    }\n  };\n}\n/**\n * Standard Android-style reveal from the bottom for Android Pie.\n */\n\nexport function forRevealFromBottomAndroid({\n  current,\n  next,\n  inverted,\n  layouts: {\n    screen\n  }\n}) {\n  const containerTranslateY = multiply(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [screen.height, 0],\n    extrapolate: 'clamp'\n  }), inverted);\n  const cardTranslateYFocused = multiply(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [screen.height * (95.9 / 100) * -1, 0],\n    extrapolate: 'clamp'\n  }), inverted);\n  const cardTranslateYUnfocused = next ? multiply(next.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, screen.height * (2 / 100) * -1],\n    extrapolate: 'clamp'\n  }), inverted) : 0;\n  const overlayOpacity = current.progress.interpolate({\n    inputRange: [0, 0.36, 1],\n    outputRange: [0, 0.1, 0.1],\n    extrapolate: 'clamp'\n  });\n  return {\n    containerStyle: {\n      overflow: 'hidden',\n      transform: [{\n        translateY: containerTranslateY\n      }]\n    },\n    cardStyle: {\n      transform: [{\n        translateY: cardTranslateYFocused\n      }, {\n        translateY: cardTranslateYUnfocused\n      }]\n    },\n    overlayStyle: {\n      opacity: overlayOpacity\n    }\n  };\n}\n/**\n * Standard Android-style reveal from the bottom for Android Q.\n */\n\nexport function forScaleFromCenterAndroid({\n  current,\n  next,\n  closing\n}) {\n  const progress = add(current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 1],\n    extrapolate: 'clamp'\n  }), next ? next.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 1],\n    extrapolate: 'clamp'\n  }) : 0);\n  const opacity = progress.interpolate({\n    inputRange: [0, 0.8, 1, 1.2, 2],\n    outputRange: [0, 0.5, 1, 0.33, 0]\n  });\n  const scale = conditional(closing, current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0.9, 1],\n    extrapolate: 'clamp'\n  }), progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: [0.85, 1, 1.1]\n  }));\n  return {\n    containerStyle: {\n      opacity,\n      transform: [{\n        scale\n      }]\n    }\n  };\n}\nexport function forNoAnimation() {\n  return {};\n}","map":null,"metadata":{},"sourceType":"module"}