{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { Animated, StyleSheet, Dimensions, Platform } from 'react-native';\nimport { MaybeScreenContainer, MaybeScreen } from '../Screens';\nimport { getDefaultHeaderHeight } from '../Header/HeaderSegment';\nimport CardContainer from './CardContainer';\nimport { DefaultTransition, ModalTransition } from '../../TransitionConfigs/TransitionPresets';\nimport { forNoAnimation as forNoAnimationHeader } from '../../TransitionConfigs/HeaderStyleInterpolators';\nimport { forNoAnimation as forNoAnimationCard } from '../../TransitionConfigs/CardStyleInterpolators';\nimport HeaderShownContext from '../../utils/HeaderShownContext';\nimport getDistanceForDirection from '../../utils/getDistanceForDirection';\nconst EPSILON = 0.01;\nconst FALLBACK_DESCRIPTOR = Object.freeze({\n  options: {}\n});\n\nconst getHeaderHeights = (routes, insets, descriptors, layout, previous) => {\n  return routes.reduce((acc, curr) => {\n    const _ref = descriptors[curr.key] || {},\n          _ref$options = _ref.options,\n          options = _ref$options === void 0 ? {} : _ref$options;\n\n    const style = StyleSheet.flatten(options.headerStyle || {});\n    const height = typeof style.height === 'number' ? style.height : previous[curr.key];\n\n    const safeAreaInsets = _objectSpread(_objectSpread({}, insets), options.safeAreaInsets);\n\n    const _options$headerStatus = options.headerStatusBarHeight,\n          headerStatusBarHeight = _options$headerStatus === void 0 ? safeAreaInsets.top : _options$headerStatus;\n    acc[curr.key] = typeof height === 'number' ? height : getDefaultHeaderHeight(layout, headerStatusBarHeight);\n    return acc;\n  }, {});\n};\n\nconst getDistanceFromOptions = (mode, layout, descriptor) => {\n  const _ref2 = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.options) || {},\n        _ref2$gestureDirectio = _ref2.gestureDirection,\n        gestureDirection = _ref2$gestureDirectio === void 0 ? mode === 'modal' ? ModalTransition.gestureDirection : DefaultTransition.gestureDirection : _ref2$gestureDirectio;\n\n  return getDistanceForDirection(layout, gestureDirection);\n};\n\nconst getProgressFromGesture = (mode, gesture, layout, descriptor) => {\n  const distance = getDistanceFromOptions(mode, {\n    // Make sure that we have a non-zero distance, otherwise there will be incorrect progress\n    // This causes blank screen on web if it was previously inside container with display: none\n    width: Math.max(1, layout.width),\n    height: Math.max(1, layout.height)\n  }, descriptor);\n\n  if (distance > 0) {\n    return gesture.interpolate({\n      inputRange: [0, distance],\n      outputRange: [1, 0]\n    });\n  }\n\n  return gesture.interpolate({\n    inputRange: [distance, 0],\n    outputRange: [0, 1]\n  });\n};\n\nexport default class CardStack extends React.Component {\n  static getDerivedStateFromProps(props, state) {\n    if (props.routes === state.routes && props.descriptors === state.descriptors) {\n      return null;\n    }\n\n    const gestures = props.routes.reduce((acc, curr) => {\n      const descriptor = props.descriptors[curr.key];\n\n      const _ref3 = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.options) || {},\n            animationEnabled = _ref3.animationEnabled;\n\n      acc[curr.key] = state.gestures[curr.key] || new Animated.Value(props.openingRouteKeys.includes(curr.key) && animationEnabled !== false ? getDistanceFromOptions(props.mode, state.layout, descriptor) : 0);\n      return acc;\n    }, {});\n    return {\n      routes: props.routes,\n      scenes: props.routes.map((route, index, self) => {\n        const previousRoute = self[index - 1];\n        const nextRoute = self[index + 1];\n        const oldScene = state.scenes[index];\n        const currentGesture = gestures[route.key];\n        const previousGesture = previousRoute ? gestures[previousRoute.key] : undefined;\n        const nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;\n        const descriptor = props.descriptors[route.key] || state.descriptors[route.key] || (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);\n        const nextDescriptor = props.descriptors[nextRoute === null || nextRoute === void 0 ? void 0 : nextRoute.key] || state.descriptors[nextRoute === null || nextRoute === void 0 ? void 0 : nextRoute.key];\n        const previousDescriptor = props.descriptors[previousRoute === null || previousRoute === void 0 ? void 0 : previousRoute.key] || state.descriptors[previousRoute === null || previousRoute === void 0 ? void 0 : previousRoute.key];\n        const scene = {\n          route,\n          descriptor,\n          progress: {\n            current: getProgressFromGesture(props.mode, currentGesture, state.layout, descriptor),\n            next: nextGesture ? getProgressFromGesture(props.mode, nextGesture, state.layout, nextDescriptor) : undefined,\n            previous: previousGesture ? getProgressFromGesture(props.mode, previousGesture, state.layout, previousDescriptor) : undefined\n          },\n          __memo: [route, state.layout, descriptor, nextDescriptor, previousDescriptor, currentGesture, nextGesture, previousGesture]\n        };\n\n        if (oldScene && scene.__memo.every((it, i) => {\n          // @ts-expect-error: we haven't added __memo to the annotation to prevent usage elsewhere\n          return oldScene.__memo[i] === it;\n        })) {\n          return oldScene;\n        }\n\n        return scene;\n      }),\n      gestures,\n      descriptors: props.descriptors,\n      headerHeights: getHeaderHeights(props.routes, props.insets, state.descriptors, state.layout, state.headerHeights)\n    };\n  }\n\n  constructor(_props) {\n    super(_props);\n\n    _defineProperty(this, \"handleLayout\", e => {\n      const _e$nativeEvent$layout = e.nativeEvent.layout,\n            height = _e$nativeEvent$layout.height,\n            width = _e$nativeEvent$layout.width;\n      const layout = {\n        width,\n        height\n      };\n      this.setState((state, props) => {\n        if (height === state.layout.height && width === state.layout.width) {\n          return null;\n        }\n\n        return {\n          layout,\n          headerHeights: getHeaderHeights(props.routes, props.insets, state.descriptors, layout, state.headerHeights)\n        };\n      });\n    });\n\n    _defineProperty(this, \"handleHeaderLayout\", ({\n      route,\n      height\n    }) => {\n      this.setState(({\n        headerHeights\n      }) => {\n        const previousHeight = headerHeights[route.key];\n\n        if (previousHeight === height) {\n          return null;\n        }\n\n        return {\n          headerHeights: _objectSpread(_objectSpread({}, headerHeights), {}, {\n            [route.key]: height\n          })\n        };\n      });\n    });\n\n    _defineProperty(this, \"getFocusedRoute\", () => {\n      const state = this.props.state;\n      return state.routes[state.index];\n    });\n\n    _defineProperty(this, \"getPreviousScene\", ({\n      route\n    }) => {\n      const getPreviousRoute = this.props.getPreviousRoute;\n      const scenes = this.state.scenes;\n      const previousRoute = getPreviousRoute({\n        route\n      });\n\n      if (previousRoute) {\n        const previousScene = scenes.find(scene => scene.route.key === previousRoute.key);\n        return previousScene;\n      }\n\n      return undefined;\n    });\n\n    const _Dimensions$get = Dimensions.get('window'),\n          _Dimensions$get$heigh = _Dimensions$get.height,\n          _height = _Dimensions$get$heigh === void 0 ? 0 : _Dimensions$get$heigh,\n          _Dimensions$get$width = _Dimensions$get.width,\n          _width = _Dimensions$get$width === void 0 ? 0 : _Dimensions$get$width;\n\n    this.state = {\n      routes: [],\n      scenes: [],\n      gestures: {},\n      layout: {\n        height: _height,\n        width: _width\n      },\n      descriptors: this.props.descriptors,\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      headerHeights: {}\n    };\n  }\n\n  render() {\n    const _this$props = this.props,\n          mode = _this$props.mode,\n          insets = _this$props.insets,\n          descriptors = _this$props.descriptors,\n          state = _this$props.state,\n          routes = _this$props.routes,\n          closingRouteKeys = _this$props.closingRouteKeys,\n          onOpenRoute = _this$props.onOpenRoute,\n          onCloseRoute = _this$props.onCloseRoute,\n          getGesturesEnabled = _this$props.getGesturesEnabled,\n          renderHeader = _this$props.renderHeader,\n          renderScene = _this$props.renderScene,\n          headerMode = _this$props.headerMode,\n          onTransitionStart = _this$props.onTransitionStart,\n          onTransitionEnd = _this$props.onTransitionEnd,\n          onPageChangeStart = _this$props.onPageChangeStart,\n          onPageChangeConfirm = _this$props.onPageChangeConfirm,\n          onPageChangeCancel = _this$props.onPageChangeCancel,\n          onGestureStart = _this$props.onGestureStart,\n          onGestureEnd = _this$props.onGestureEnd,\n          onGestureCancel = _this$props.onGestureCancel;\n    const _this$state = this.state,\n          scenes = _this$state.scenes,\n          layout = _this$state.layout,\n          gestures = _this$state.gestures,\n          headerHeights = _this$state.headerHeights;\n    const focusedRoute = state.routes[state.index];\n    const focusedDescriptor = descriptors[focusedRoute.key];\n    const focusedOptions = focusedDescriptor ? focusedDescriptor.options : {};\n    let defaultTransitionPreset = mode === 'modal' ? ModalTransition : DefaultTransition;\n\n    if (headerMode === 'screen') {\n      defaultTransitionPreset = _objectSpread(_objectSpread({}, defaultTransitionPreset), {}, {\n        headerStyleInterpolator: forNoAnimationHeader\n      });\n    }\n\n    const _ref4 = focusedOptions.safeAreaInsets || {},\n          _ref4$top = _ref4.top,\n          top = _ref4$top === void 0 ? insets.top : _ref4$top,\n          _ref4$right = _ref4.right,\n          right = _ref4$right === void 0 ? insets.right : _ref4$right,\n          _ref4$bottom = _ref4.bottom,\n          bottom = _ref4$bottom === void 0 ? insets.bottom : _ref4$bottom,\n          _ref4$left = _ref4.left,\n          left = _ref4$left === void 0 ? insets.left : _ref4$left; // Screens is buggy on iOS and web, so we only enable it on Android\n    // For modals, usually we want the screen underneath to be visible, so also disable it there\n\n\n    const isScreensEnabled = Platform.OS !== 'ios' && mode !== 'modal';\n    return /*#__PURE__*/React.createElement(HeaderShownContext.Consumer, null, isParentHeaderShown => {\n      const isFloatHeaderAbsolute = headerMode === 'float' ? this.state.scenes.slice(-2).some(scene => {\n        const descriptor = scene.descriptor;\n        const options = descriptor ? descriptor.options : {};\n        const headerTransparent = options.headerTransparent,\n              _options$headerShown = options.headerShown,\n              headerShown = _options$headerShown === void 0 ? isParentHeaderShown === false : _options$headerShown;\n\n        if (headerTransparent || headerShown === false) {\n          return true;\n        }\n\n        return false;\n      }) : false;\n      const floatingHeader = headerMode === 'float' ? /*#__PURE__*/React.createElement(React.Fragment, {\n        key: \"header\"\n      }, renderHeader({\n        mode: 'float',\n        layout,\n        insets: {\n          top,\n          right,\n          bottom,\n          left\n        },\n        scenes,\n        getPreviousScene: this.getPreviousScene,\n        getFocusedRoute: this.getFocusedRoute,\n        onContentHeightChange: this.handleHeaderLayout,\n        gestureDirection: focusedOptions.gestureDirection !== undefined ? focusedOptions.gestureDirection : defaultTransitionPreset.gestureDirection,\n        styleInterpolator: focusedOptions.headerStyleInterpolator !== undefined ? focusedOptions.headerStyleInterpolator : defaultTransitionPreset.headerStyleInterpolator,\n        style: [styles.floating, isFloatHeaderAbsolute && styles.absolute]\n      })) : null;\n      return /*#__PURE__*/React.createElement(React.Fragment, null, isFloatHeaderAbsolute ? null : floatingHeader, /*#__PURE__*/React.createElement(MaybeScreenContainer, {\n        enabled: isScreensEnabled,\n        style: styles.container,\n        onLayout: this.handleLayout\n      }, routes.map((route, index, self) => {\n        const focused = focusedRoute.key === route.key;\n        const gesture = gestures[route.key];\n        const scene = scenes[index];\n        const isScreenActive = scene.progress.next ? scene.progress.next.interpolate({\n          inputRange: [0, 1 - EPSILON, 1],\n          outputRange: [1, 1, 0],\n          extrapolate: 'clamp'\n        }) : 1;\n\n        const _ref5 = scene.descriptor ? scene.descriptor.options : {},\n              safeAreaInsets = _ref5.safeAreaInsets,\n              _ref5$headerShown = _ref5.headerShown,\n              headerShown = _ref5$headerShown === void 0 ? isParentHeaderShown === false : _ref5$headerShown,\n              headerTransparent = _ref5.headerTransparent,\n              cardShadowEnabled = _ref5.cardShadowEnabled,\n              cardOverlayEnabled = _ref5.cardOverlayEnabled,\n              cardOverlay = _ref5.cardOverlay,\n              cardStyle = _ref5.cardStyle,\n              animationEnabled = _ref5.animationEnabled,\n              gestureResponseDistance = _ref5.gestureResponseDistance,\n              gestureVelocityImpact = _ref5.gestureVelocityImpact,\n              _ref5$gestureDirectio = _ref5.gestureDirection,\n              gestureDirection = _ref5$gestureDirectio === void 0 ? defaultTransitionPreset.gestureDirection : _ref5$gestureDirectio,\n              _ref5$transitionSpec = _ref5.transitionSpec,\n              transitionSpec = _ref5$transitionSpec === void 0 ? defaultTransitionPreset.transitionSpec : _ref5$transitionSpec,\n              _ref5$cardStyleInterp = _ref5.cardStyleInterpolator,\n              cardStyleInterpolator = _ref5$cardStyleInterp === void 0 ? animationEnabled === false ? forNoAnimationCard : defaultTransitionPreset.cardStyleInterpolator : _ref5$cardStyleInterp,\n              _ref5$headerStyleInte = _ref5.headerStyleInterpolator,\n              headerStyleInterpolator = _ref5$headerStyleInte === void 0 ? defaultTransitionPreset.headerStyleInterpolator : _ref5$headerStyleInte;\n\n        let transitionConfig = {\n          gestureDirection,\n          transitionSpec,\n          cardStyleInterpolator,\n          headerStyleInterpolator\n        }; // When a screen is not the last, it should use next screen's transition config\n        // Many transitions also animate the previous screen, so using 2 different transitions doesn't look right\n        // For example combining a slide and a modal transition would look wrong otherwise\n        // With this approach, combining different transition styles in the same navigator mostly looks right\n        // This will still be broken when 2 transitions have different idle state (e.g. modal presentation),\n        // but majority of the transitions look alright\n\n        if (index !== self.length - 1) {\n          const nextScene = scenes[index + 1];\n\n          if (nextScene) {\n            const _ref6 = nextScene.descriptor ? nextScene.descriptor.options : {},\n                  animationEnabled = _ref6.animationEnabled,\n                  _ref6$gestureDirectio = _ref6.gestureDirection,\n                  gestureDirection = _ref6$gestureDirectio === void 0 ? defaultTransitionPreset.gestureDirection : _ref6$gestureDirectio,\n                  _ref6$transitionSpec = _ref6.transitionSpec,\n                  transitionSpec = _ref6$transitionSpec === void 0 ? defaultTransitionPreset.transitionSpec : _ref6$transitionSpec,\n                  _ref6$cardStyleInterp = _ref6.cardStyleInterpolator,\n                  cardStyleInterpolator = _ref6$cardStyleInterp === void 0 ? animationEnabled === false ? forNoAnimationCard : defaultTransitionPreset.cardStyleInterpolator : _ref6$cardStyleInterp,\n                  _ref6$headerStyleInte = _ref6.headerStyleInterpolator,\n                  headerStyleInterpolator = _ref6$headerStyleInte === void 0 ? defaultTransitionPreset.headerStyleInterpolator : _ref6$headerStyleInte;\n\n            transitionConfig = {\n              gestureDirection,\n              transitionSpec,\n              cardStyleInterpolator,\n              headerStyleInterpolator\n            };\n          }\n        }\n\n        const _ref7 = safeAreaInsets || {},\n              _ref7$top = _ref7.top,\n              safeAreaInsetTop = _ref7$top === void 0 ? insets.top : _ref7$top,\n              _ref7$right = _ref7.right,\n              safeAreaInsetRight = _ref7$right === void 0 ? insets.right : _ref7$right,\n              _ref7$bottom = _ref7.bottom,\n              safeAreaInsetBottom = _ref7$bottom === void 0 ? insets.bottom : _ref7$bottom,\n              _ref7$left = _ref7.left,\n              safeAreaInsetLeft = _ref7$left === void 0 ? insets.left : _ref7$left;\n\n        const headerHeight = headerMode !== 'none' && headerShown !== false ? headerHeights[route.key] : 0;\n        return /*#__PURE__*/React.createElement(MaybeScreen, {\n          key: route.key,\n          style: StyleSheet.absoluteFill,\n          enabled: isScreensEnabled,\n          active: isScreenActive,\n          pointerEvents: \"box-none\"\n        }, /*#__PURE__*/React.createElement(CardContainer, _extends({\n          index: index,\n          active: index === self.length - 1,\n          focused: focused,\n          closing: closingRouteKeys.includes(route.key),\n          layout: layout,\n          gesture: gesture,\n          scene: scene,\n          safeAreaInsetTop: safeAreaInsetTop,\n          safeAreaInsetRight: safeAreaInsetRight,\n          safeAreaInsetBottom: safeAreaInsetBottom,\n          safeAreaInsetLeft: safeAreaInsetLeft,\n          cardOverlay: cardOverlay,\n          cardOverlayEnabled: cardOverlayEnabled,\n          cardShadowEnabled: cardShadowEnabled,\n          cardStyle: cardStyle,\n          onPageChangeStart: onPageChangeStart,\n          onPageChangeConfirm: onPageChangeConfirm,\n          onPageChangeCancel: onPageChangeCancel,\n          onGestureStart: onGestureStart,\n          onGestureCancel: onGestureCancel,\n          onGestureEnd: onGestureEnd,\n          gestureResponseDistance: gestureResponseDistance,\n          headerHeight: headerHeight,\n          onHeaderHeightChange: this.handleHeaderLayout,\n          getPreviousScene: this.getPreviousScene,\n          getFocusedRoute: this.getFocusedRoute,\n          mode: mode,\n          headerMode: headerMode,\n          headerShown: headerShown,\n          hasAbsoluteHeader: isFloatHeaderAbsolute && !headerTransparent,\n          renderHeader: renderHeader,\n          renderScene: renderScene,\n          onOpenRoute: onOpenRoute,\n          onCloseRoute: onCloseRoute,\n          onTransitionStart: onTransitionStart,\n          onTransitionEnd: onTransitionEnd,\n          gestureEnabled: index !== 0 && getGesturesEnabled({\n            route\n          }),\n          gestureVelocityImpact: gestureVelocityImpact\n        }, transitionConfig)));\n      })), isFloatHeaderAbsolute ? floatingHeader : null);\n    });\n  }\n\n}\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  absolute: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0\n  },\n  floating: {\n    zIndex: 1\n  }\n});","map":null,"metadata":{},"sourceType":"module"}