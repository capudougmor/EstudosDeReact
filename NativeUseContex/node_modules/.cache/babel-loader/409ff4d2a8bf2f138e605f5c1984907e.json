{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { Animated, View, StyleSheet, Platform, InteractionManager } from 'react-native';\nimport Color from 'color';\nimport CardSheet from './CardSheet';\nimport { PanGestureHandler, GestureState } from '../GestureHandler';\nimport CardAnimationContext from '../../utils/CardAnimationContext';\nimport getDistanceForDirection from '../../utils/getDistanceForDirection';\nimport getInvertedMultiplier from '../../utils/getInvertedMultiplier';\nimport memoize from '../../utils/memoize';\nconst GESTURE_VELOCITY_IMPACT = 0.3;\nconst TRUE = 1;\nconst FALSE = 0;\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\n\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\nconst useNativeDriver = Platform.OS !== 'web';\nexport default class Card extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"isCurrentlyMounted\", false);\n\n    _defineProperty(this, \"isClosing\", new Animated.Value(FALSE));\n\n    _defineProperty(this, \"inverted\", new Animated.Value(getInvertedMultiplier(this.props.gestureDirection)));\n\n    _defineProperty(this, \"layout\", {\n      width: new Animated.Value(this.props.layout.width),\n      height: new Animated.Value(this.props.layout.height)\n    });\n\n    _defineProperty(this, \"isSwiping\", new Animated.Value(FALSE));\n\n    _defineProperty(this, \"interactionHandle\", void 0);\n\n    _defineProperty(this, \"pendingGestureCallback\", void 0);\n\n    _defineProperty(this, \"lastToValue\", void 0);\n\n    _defineProperty(this, \"animate\", ({\n      closing,\n      velocity\n    }) => {\n      const _this$props2 = this.props,\n            gesture = _this$props2.gesture,\n            transitionSpec = _this$props2.transitionSpec,\n            onOpen = _this$props2.onOpen,\n            onClose = _this$props2.onClose,\n            onTransitionStart = _this$props2.onTransitionStart;\n      const toValue = this.getAnimateToValue(_objectSpread(_objectSpread({}, this.props), {}, {\n        closing\n      }));\n      this.lastToValue = toValue;\n      const spec = closing ? transitionSpec.close : transitionSpec.open;\n      const animation = spec.animation === 'spring' ? Animated.spring : Animated.timing;\n      this.setPointerEventsEnabled(!closing);\n      this.handleStartInteraction();\n      clearTimeout(this.pendingGestureCallback);\n      onTransitionStart === null || onTransitionStart === void 0 ? void 0 : onTransitionStart({\n        closing\n      });\n      animation(gesture, _objectSpread(_objectSpread({}, spec.config), {}, {\n        velocity,\n        toValue,\n        useNativeDriver,\n        isInteraction: false\n      })).start(({\n        finished\n      }) => {\n        this.handleEndInteraction();\n        clearTimeout(this.pendingGestureCallback);\n\n        if (finished) {\n          if (closing) {\n            onClose();\n          } else {\n            onOpen();\n          }\n\n          if (this.isCurrentlyMounted) {\n            // Make sure to re-open screen if it wasn't removed\n            this.forceUpdate();\n          }\n        }\n      });\n    });\n\n    _defineProperty(this, \"getAnimateToValue\", ({\n      closing,\n      layout,\n      gestureDirection\n    }) => {\n      if (!closing) {\n        return 0;\n      }\n\n      return getDistanceForDirection(layout, gestureDirection);\n    });\n\n    _defineProperty(this, \"setPointerEventsEnabled\", enabled => {\n      var _this$contentRef$curr;\n\n      const pointerEvents = enabled ? 'box-none' : 'none';\n      (_this$contentRef$curr = this.contentRef.current) === null || _this$contentRef$curr === void 0 ? void 0 : _this$contentRef$curr.setNativeProps({\n        pointerEvents\n      });\n    });\n\n    _defineProperty(this, \"handleStartInteraction\", () => {\n      if (this.interactionHandle === undefined) {\n        this.interactionHandle = InteractionManager.createInteractionHandle();\n      }\n    });\n\n    _defineProperty(this, \"handleEndInteraction\", () => {\n      if (this.interactionHandle !== undefined) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n        this.interactionHandle = undefined;\n      }\n    });\n\n    _defineProperty(this, \"handleGestureStateChange\", ({\n      nativeEvent\n    }) => {\n      const _this$props3 = this.props,\n            layout = _this$props3.layout,\n            onClose = _this$props3.onClose,\n            onGestureBegin = _this$props3.onGestureBegin,\n            onGestureCanceled = _this$props3.onGestureCanceled,\n            onGestureEnd = _this$props3.onGestureEnd,\n            gestureDirection = _this$props3.gestureDirection,\n            gestureVelocityImpact = _this$props3.gestureVelocityImpact;\n\n      switch (nativeEvent.state) {\n        case GestureState.BEGAN:\n          this.isSwiping.setValue(TRUE);\n          this.handleStartInteraction();\n          onGestureBegin === null || onGestureBegin === void 0 ? void 0 : onGestureBegin();\n          break;\n\n        case GestureState.CANCELLED:\n          {\n            this.isSwiping.setValue(FALSE);\n            this.handleEndInteraction();\n            const velocity = gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? nativeEvent.velocityY : nativeEvent.velocityX;\n            this.animate({\n              closing: this.props.closing,\n              velocity\n            });\n            onGestureCanceled === null || onGestureCanceled === void 0 ? void 0 : onGestureCanceled();\n            break;\n          }\n\n        case GestureState.END:\n          {\n            this.isSwiping.setValue(FALSE);\n            let distance;\n            let translation;\n            let velocity;\n\n            if (gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted') {\n              distance = layout.height;\n              translation = nativeEvent.translationY;\n              velocity = nativeEvent.velocityY;\n            } else {\n              distance = layout.width;\n              translation = nativeEvent.translationX;\n              velocity = nativeEvent.velocityX;\n            }\n\n            const closing = (translation + velocity * gestureVelocityImpact) * getInvertedMultiplier(gestureDirection) > distance / 2 ? velocity !== 0 || translation !== 0 : this.props.closing;\n            this.animate({\n              closing,\n              velocity\n            });\n\n            if (closing) {\n              // We call onClose with a delay to make sure that the animation has already started\n              // This will make sure that the state update caused by this doesn't affect start of animation\n              this.pendingGestureCallback = setTimeout(() => {\n                onClose(); // Trigger an update after we dispatch the action to remove the screen\n                // This will make sure that we check if the screen didn't get removed so we can cancel the animation\n\n                this.forceUpdate();\n              }, 32);\n            }\n\n            onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd();\n            break;\n          }\n      }\n    });\n\n    _defineProperty(this, \"getInterpolatedStyle\", memoize((styleInterpolator, index, current, next, layout, insetTop, insetRight, insetBottom, insetLeft) => styleInterpolator({\n      index,\n      current: {\n        progress: current\n      },\n      next: next && {\n        progress: next\n      },\n      closing: this.isClosing,\n      swiping: this.isSwiping,\n      inverted: this.inverted,\n      layouts: {\n        screen: layout\n      },\n      insets: {\n        top: insetTop,\n        right: insetRight,\n        bottom: insetBottom,\n        left: insetLeft\n      }\n    })));\n\n    _defineProperty(this, \"getCardAnimationContext\", memoize((index, current, next, layout, insetTop, insetRight, insetBottom, insetLeft) => ({\n      index,\n      current: {\n        progress: current\n      },\n      next: next && {\n        progress: next\n      },\n      closing: this.isClosing,\n      swiping: this.isSwiping,\n      inverted: this.inverted,\n      layouts: {\n        screen: layout\n      },\n      insets: {\n        top: insetTop,\n        right: insetRight,\n        bottom: insetBottom,\n        left: insetLeft\n      }\n    })));\n\n    _defineProperty(this, \"contentRef\", /*#__PURE__*/React.createRef());\n  }\n\n  componentDidMount() {\n    this.animate({\n      closing: this.props.closing\n    });\n    this.isCurrentlyMounted = true;\n  }\n\n  componentDidUpdate(prevProps) {\n    const _this$props4 = this.props,\n          layout = _this$props4.layout,\n          gestureDirection = _this$props4.gestureDirection,\n          closing = _this$props4.closing;\n    const width = layout.width,\n          height = layout.height;\n\n    if (width !== prevProps.layout.width) {\n      this.layout.width.setValue(width);\n    }\n\n    if (height !== prevProps.layout.height) {\n      this.layout.height.setValue(height);\n    }\n\n    if (gestureDirection !== prevProps.gestureDirection) {\n      this.inverted.setValue(getInvertedMultiplier(gestureDirection));\n    }\n\n    const toValue = this.getAnimateToValue(this.props);\n\n    if (this.getAnimateToValue(prevProps) !== toValue || this.lastToValue !== toValue) {\n      // We need to trigger the animation when route was closed\n      // Thr route might have been closed by a `POP` action or by a gesture\n      // When route was closed due to a gesture, the animation would've happened already\n      // It's still important to trigger the animation so that `onClose` is called\n      // If `onClose` is not called, cleanup step won't be performed for gestures\n      this.animate({\n        closing\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.isCurrentlyMounted = false;\n    this.handleEndInteraction();\n  }\n\n  gestureActivationCriteria() {\n    const _this$props5 = this.props,\n          layout = _this$props5.layout,\n          gestureDirection = _this$props5.gestureDirection,\n          gestureResponseDistance = _this$props5.gestureResponseDistance;\n    const distance = gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? (gestureResponseDistance === null || gestureResponseDistance === void 0 ? void 0 : gestureResponseDistance.vertical) !== undefined ? gestureResponseDistance.vertical : GESTURE_RESPONSE_DISTANCE_VERTICAL : (gestureResponseDistance === null || gestureResponseDistance === void 0 ? void 0 : gestureResponseDistance.horizontal) !== undefined ? gestureResponseDistance.horizontal : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n    if (gestureDirection === 'vertical') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: 5,\n        hitSlop: {\n          bottom: -layout.height + distance\n        }\n      };\n    } else if (gestureDirection === 'vertical-inverted') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: -5,\n        hitSlop: {\n          top: -layout.height + distance\n        }\n      };\n    } else {\n      const hitSlop = -layout.width + distance;\n      const invertedMultiplier = getInvertedMultiplier(gestureDirection);\n\n      if (invertedMultiplier === 1) {\n        return {\n          minOffsetX: 5,\n          maxDeltaY: 20,\n          hitSlop: {\n            right: hitSlop\n          }\n        };\n      } else {\n        return {\n          minOffsetX: -5,\n          maxDeltaY: 20,\n          hitSlop: {\n            left: hitSlop\n          }\n        };\n      }\n    }\n  }\n\n  render() {\n    const _this$props = this.props,\n          styleInterpolator = _this$props.styleInterpolator,\n          index = _this$props.index,\n          current = _this$props.current,\n          gesture = _this$props.gesture,\n          next = _this$props.next,\n          layout = _this$props.layout,\n          insets = _this$props.insets,\n          overlay = _this$props.overlay,\n          overlayEnabled = _this$props.overlayEnabled,\n          shadowEnabled = _this$props.shadowEnabled,\n          gestureEnabled = _this$props.gestureEnabled,\n          gestureDirection = _this$props.gestureDirection,\n          pageOverflowEnabled = _this$props.pageOverflowEnabled,\n          children = _this$props.children,\n          customContainerStyle = _this$props.containerStyle,\n          contentStyle = _this$props.contentStyle,\n          rest = _objectWithoutProperties(_this$props, [\"styleInterpolator\", \"index\", \"current\", \"gesture\", \"next\", \"layout\", \"insets\", \"overlay\", \"overlayEnabled\", \"shadowEnabled\", \"gestureEnabled\", \"gestureDirection\", \"pageOverflowEnabled\", \"children\", \"containerStyle\", \"contentStyle\"]);\n\n    const interpolatedStyle = this.getInterpolatedStyle(styleInterpolator, index, current, next, layout, insets.top, insets.right, insets.bottom, insets.left);\n    const animationContext = this.getCardAnimationContext(index, current, next, layout, insets.top, insets.right, insets.bottom, insets.left);\n    const containerStyle = interpolatedStyle.containerStyle,\n          cardStyle = interpolatedStyle.cardStyle,\n          overlayStyle = interpolatedStyle.overlayStyle,\n          shadowStyle = interpolatedStyle.shadowStyle;\n    const handleGestureEvent = gestureEnabled ? Animated.event([{\n      nativeEvent: gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? {\n        translationY: gesture\n      } : {\n        translationX: gesture\n      }\n    }], {\n      useNativeDriver\n    }) : undefined;\n\n    const _StyleSheet$flatten = StyleSheet.flatten(contentStyle || {}),\n          backgroundColor = _StyleSheet$flatten.backgroundColor;\n\n    const isTransparent = backgroundColor ? Color(backgroundColor).alpha() === 0 : false;\n    return /*#__PURE__*/React.createElement(CardAnimationContext.Provider, {\n      value: animationContext\n    }, /*#__PURE__*/React.createElement(Animated.View, {\n      style: {\n        // This is a dummy style that doesn't actually change anything visually.\n        // Animated needs the animated value to be used somewhere, otherwise things don't update properly.\n        // If we disable animations and hide header, it could end up making the value unused.\n        // So we have this dummy style that will always be used regardless of what else changed.\n        opacity: current\n      } // Make sure that this view isn't removed. If this view is removed, our style with animated value won't apply\n      ,\n      collapsable: false\n    }), /*#__PURE__*/React.createElement(View, _extends({\n      pointerEvents: \"box-none\"\n    }, rest), overlayEnabled ? /*#__PURE__*/React.createElement(View, {\n      pointerEvents: \"box-none\",\n      style: StyleSheet.absoluteFill\n    }, overlay({\n      style: overlayStyle\n    })) : null, /*#__PURE__*/React.createElement(Animated.View, {\n      style: [styles.container, containerStyle, customContainerStyle],\n      pointerEvents: \"box-none\"\n    }, /*#__PURE__*/React.createElement(PanGestureHandler, _extends({\n      enabled: layout.width !== 0 && gestureEnabled,\n      onGestureEvent: handleGestureEvent,\n      onHandlerStateChange: this.handleGestureStateChange\n    }, this.gestureActivationCriteria()), /*#__PURE__*/React.createElement(Animated.View, {\n      style: [styles.container, cardStyle]\n    }, shadowEnabled && shadowStyle && !isTransparent ? /*#__PURE__*/React.createElement(Animated.View, {\n      style: [styles.shadow, gestureDirection === 'horizontal' ? [styles.shadowHorizontal, styles.shadowLeft] : gestureDirection === 'horizontal-inverted' ? [styles.shadowHorizontal, styles.shadowRight] : gestureDirection === 'vertical' ? [styles.shadowVertical, styles.shadowTop] : [styles.shadowVertical, styles.shadowBottom], {\n        backgroundColor\n      }, shadowStyle],\n      pointerEvents: \"none\"\n    }) : null, /*#__PURE__*/React.createElement(CardSheet, {\n      ref: this.contentRef,\n      enabled: pageOverflowEnabled,\n      layout: layout,\n      style: contentStyle\n    }, children))))));\n  }\n\n}\n\n_defineProperty(Card, \"defaultProps\", {\n  overlayEnabled: Platform.OS !== 'ios',\n  shadowEnabled: true,\n  gestureEnabled: true,\n  gestureVelocityImpact: GESTURE_VELOCITY_IMPACT,\n  overlay: ({\n    style\n  }) => style ? /*#__PURE__*/React.createElement(Animated.View, {\n    pointerEvents: \"none\",\n    style: [styles.overlay, style]\n  }) : null\n});\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  overlay: {\n    flex: 1,\n    backgroundColor: '#000'\n  },\n  shadow: {\n    position: 'absolute',\n    shadowRadius: 5,\n    shadowColor: '#000',\n    shadowOpacity: 0.3\n  },\n  shadowHorizontal: {\n    top: 0,\n    bottom: 0,\n    width: 3,\n    shadowOffset: {\n      width: -1,\n      height: 1\n    }\n  },\n  shadowLeft: {\n    left: 0\n  },\n  shadowRight: {\n    right: 0\n  },\n  shadowVertical: {\n    left: 0,\n    right: 0,\n    height: 3,\n    shadowOffset: {\n      width: 1,\n      height: -1\n    }\n  },\n  shadowTop: {\n    top: 0\n  },\n  shadowBottom: {\n    bottom: 0\n  }\n});","map":null,"metadata":{},"sourceType":"module"}