{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { TextInput, Platform, Keyboard } from 'react-native';\nexport default class KeyboardManager extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"previouslyFocusedTextInput\", null);\n\n    _defineProperty(this, \"startTimestamp\", 0);\n\n    _defineProperty(this, \"keyboardTimeout\", void 0);\n\n    _defineProperty(this, \"clearKeyboardTimeout\", () => {\n      if (this.keyboardTimeout !== undefined) {\n        clearTimeout(this.keyboardTimeout);\n        this.keyboardTimeout = undefined;\n      }\n    });\n\n    _defineProperty(this, \"handlePageChangeStart\", () => {\n      if (!this.props.enabled) {\n        return;\n      }\n\n      this.clearKeyboardTimeout(); // @ts-expect-error: currentlyFocusedInput is pretty new, so not in the type definitions\n\n      const input = TextInput.State.currentlyFocusedInput ? // @ts-expect-error\n      TextInput.State.currentlyFocusedInput() : TextInput.State.currentlyFocusedField(); // When a page change begins, blur the currently focused input\n\n      TextInput.State.blurTextInput(input); // Store the id of this input so we can refocus it if change was cancelled\n\n      this.previouslyFocusedTextInput = input; // Store timestamp for touch start\n\n      this.startTimestamp = Date.now();\n    });\n\n    _defineProperty(this, \"handlePageChangeConfirm\", () => {\n      if (!this.props.enabled) {\n        return;\n      }\n\n      this.clearKeyboardTimeout();\n      const input = this.previouslyFocusedTextInput;\n\n      if (Platform.OS === 'android') {\n        Keyboard.dismiss();\n      } else if (input) {\n        TextInput.State.blurTextInput(input);\n      } // Cleanup the ID on successful page change\n\n\n      this.previouslyFocusedTextInput = null;\n    });\n\n    _defineProperty(this, \"handlePageChangeCancel\", () => {\n      if (!this.props.enabled) {\n        return;\n      }\n\n      this.clearKeyboardTimeout(); // The page didn't change, we should restore the focus of text input\n\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // If the interaction was super short we should make sure keyboard won't hide again.\n        // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n        // During first ~100ms keyboard will be dismissed no matter what,\n        // so we have to make sure it won't interrupt input refocus logic.\n        // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n        // Subtracting timestamps makes us sure the delay is executed only when needed.\n        if (Date.now() - this.startTimestamp < 100) {\n          this.keyboardTimeout = setTimeout(() => {\n            TextInput.State.focusTextInput(input);\n            this.previouslyFocusedTextInput = null;\n          }, 100);\n        } else {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }\n      }\n    });\n  }\n\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  } // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}