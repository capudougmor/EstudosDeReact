{"ast":null,"code":"import _objectSpread from \"/workspace/EstudosDeReact/NativeUseContex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"/workspace/EstudosDeReact/NativeUseContex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria({\n    x,\n    y,\n    deltaX,\n    deltaY\n  }, {\n    maxDeltaX,\n    maxDeltaY,\n    maxDistSq,\n    shouldCancelWhenOutside\n  }) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({\n        x,\n        y\n      })) {\n        return true;\n      }\n    }\n\n    return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n  }\n\n  transformNativeEvent({\n    center: {\n      x,\n      y\n    }\n  }) {\n    const rect = this.view.getBoundingClientRect();\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top\n    };\n  }\n\n  isGestureEnabledForEvent({\n    minPointers,\n    maxPointers,\n    maxDist,\n    maxDeltaX,\n    maxDeltaY,\n    maxDistSq,\n    shouldCancelWhenOutside\n  }, recognizer, _ref) {\n    let pointerLength = _ref.maxPointers,\n        center = _ref.center,\n        deltaX = _ref.deltaX,\n        deltaY = _ref.deltaY,\n        props = _objectWithoutProperties(_ref, [\"maxPointers\", \"center\", \"deltaX\", \"deltaY\"]);\n\n    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (this.shouldFailUnderCustomCriteria(_objectSpread(_objectSpread({}, center), {}, {\n      deltaX,\n      deltaY\n    }), {\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    }) || // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n    // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n    !validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n\n    return {\n      success: validPointerCount\n    };\n  }\n\n}\n\nexport default DiscreteGestureHandler;","map":{"version":3,"sources":["/workspace/EstudosDeReact/NativeUseContex/node_modules/react-native-gesture-handler/web/DiscreteGestureHandler.js"],"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","isGestureEnabledForEvent","minPointers","maxPointers","maxDist","recognizer","pointerLength","props","validPointerCount","isGestureRunning","failed","success"],"mappings":";;AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SAASC,mBAAT,QAAoC,SAApC;;AAEA,MAAMC,sBAAN,SAAqCF,cAArC,CAAoD;AAClD,MAAIG,UAAJ,GAAiB;AACf,WAAO,IAAP;AACD;;AAED,MAAIC,0BAAJ,GAAiC;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,CAC3B;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAD2B,EAE3B;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,SAAxB;AAAmCC,IAAAA;AAAnC,GAF2B,EAG3B;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACEN,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACAT,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADnB,IAEAV,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CAAD,EAA8CI,SAA9C,CAHrB;AAKD;;AAEDK,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAEZ,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AAAV,GAAD,EAAuB;AACzC,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAUC,qBAAV,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,CACtB;AAAEC,IAAAA,WAAF;AAAeC,IAAAA,WAAf;AAA4BC,IAAAA,OAA5B;AAAqCnB,IAAAA,SAArC;AAAgDC,IAAAA,SAAhD;AAA2DC,IAAAA,SAA3D;AAAsEC,IAAAA;AAAtE,GADsB,EAEtBiB,UAFsB,QAItB;AAAA,QADeC,aACf,QADEH,WACF;AAAA,QAD8BV,MAC9B,QAD8BA,MAC9B;AAAA,QADsCV,MACtC,QADsCA,MACtC;AAAA,QAD8CC,MAC9C,QAD8CA,MAC9C;AAAA,QADyDuB,KACzD;;AACA,UAAMC,iBAAiB,GAAGF,aAAa,IAAIJ,WAAjB,IAAgCI,aAAa,IAAIH,WAA3E;;AAEA,QACE,KAAKvB,6BAAL,iCACOa,MADP;AACeV,MAAAA,MADf;AACuBC,MAAAA;AADvB,QAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACoB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AA7DiD;;AAgEpD,eAAe/B,sBAAf","sourcesContent":["import GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY },\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq)\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }) {\n    const rect = this.view.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers, maxDist, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside },\n    recognizer,\n    { maxPointers: pointerLength, center, deltaX, deltaY, ...props }\n  ) {\n    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"]},"metadata":{},"sourceType":"module"}